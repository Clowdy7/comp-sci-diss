package uk.ac.bham.cs.domct.physicsengine.systems.physics.collision;

import uk.ac.bham.cs.domct.physicsengine.component.Movable;
import uk.ac.bham.cs.domct.physicsengine.entity.Entity;
import uk.ac.bham.cs.domct.physicsengine.systems.physics.collision.contactGeneration.ContactPoint;
import uk.ac.bham.cs.domct.physicsengine.systems.physics.collision.detection.narrowphase.Simplex;

/**
 * Stores all the information about the collision between two entities. Implements
 * comparable and and override equals method to ensure the correct behaviour when
 * added to sets.
 * 
 * @author Dominic Cogan-Tucker
 *
 */
public class Collision implements Comparable<Collision>
{
	/**
	 * The first entity involved in the collision.
	 */
	protected Entity a;
	
	/**
	 * The second entity involved in the collision.
	 */
	protected Entity b;
	
	/**
	 * The simplex generated by GJK for the collision.
	 */
	protected Simplex sim;
	
	/**
	 * The contact point generated by EPA for the collision.
	 */
	protected ContactPoint contact;
	
	/**
	 * Constructs a Collision object for the given entities.
	 * 
	 * @param a The first entity in the collision.
	 * @param b The second entity in the collision.
	 */
	public Collision(Entity a, Entity b)
	{
		// If one of the entities isn't movable it is set as the
		// second entity in the collision.
		if (a.hasComponent(Movable.class))
		{
			this.a = a;
			this.b = b;
		}
		else
		{
			this.a = b;
			this.b = a;
		}
	}
	
	/**
	 * Returns the first entity in the collision.
	 * 
	 * @return The first entity in the collision.
	 */
	public Entity getEntityA()
	{
		return a;
	}
	
	/**
	 * Returns the second entity in the collision.
	 * 
	 * @return The second entity in the collision.
	 */
	public Entity getEntityB()
	{
		return b;
	}
	
	/**
	 * Returns the simplex of the collision.
	 * 
	 * @return The simplex of the collison.
	 */
	public Simplex getSimplex()
	{
		return sim;
	}
	
	/**
	 * Sets the simplex as the given simplex.
	 * 
	 * @param sim The sim to set.
	 */
	public void setSimplex(Simplex sim)
	{
		this.sim = sim;
	}
	
	/**
	 * Returns the contact point of the collision.
	 * 
	 * @return The contact point of the collision.
	 */
	public ContactPoint getContact()
	{
		return contact;
	}

	/**
	 * Two collisions are equal if the entities involved are the same. This is used
	 * to help manage collisions over multiple frames.
	 * 
	 * @return true if the collisions are between the same pair of entities.
	 */
	@Override
	public boolean equals(Object o)
	{
		if (o == null)
		{
			return false;
		}
		if (!o.getClass().equals(getClass()))
		{
			return false;
		}
		return (a.equals(((Collision) o).a) && b.equals(((Collision) o).b)) || 
				(a.equals(((Collision) o).b) && b.equals(((Collision) o).a));
	}
	

	/**
	 * Returns 1 if the collisions aren't the same, and 0 otherwise. There is no return
	 * of -1 as the collisions don't need to be ordered but as they are mutable they can't
	 * be used reliably in a hash set, so need a compareTo method to be insetred into a tree
	 * set.
	 * 
	 * @return 1 if the collision being compared aren't equal, 0 if
	 * they are.
	 */
	@Override
	public int compareTo(Collision col)
	{
		if (this.equals(col))
		{
			return 0;
		}
		else
		{
			return 1;
		}
	}

	/*
	 * Returns a readable string stating that the entities a and b are colliding.
	 */
	@Override
	public String toString()
	{
		return "Entities, " + a + " and " + b + " are colliding";
	}
}
